package com.example.myaiapp.chat.data.agents.docker

import com.example.myaiapp.chat.data.model.OllamaChatMessage
import com.example.myaiapp.chat.data.model.OllamaChatRequest
import com.example.myaiapp.chat.data.model.OllamaOptions
import com.example.myaiapp.chat.data.model.Role
import com.example.myaiapp.chat.data.ssh.SshDockerExecutor
import com.example.myaiapp.chat.data.ssh.SshDockerExecutor.RunResult
import com.example.myaiapp.chat.domain.PromptBuilder
import com.example.myaiapp.chat.domain.model.LlmModels
import com.example.myaiapp.chat.domain.model.ResponseType
import com.example.myaiapp.data_provider.DataProvider
import com.example.myaiapp.network.AIApi
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject

class DockerRepository @Inject constructor(
    private val api: AIApi,
    private val dataProvider: DataProvider,
) {

    private val history: MutableList<OllamaChatMessage> = mutableListOf(
        OllamaChatMessage(Role.SYSTEM, PromptBuilder.systemPrompt(ResponseType.DOCKER_KOTLIN_TEST))
    )

    suspend fun callLlmToDocker(content: String): RunResult {
        return withContext(Dispatchers.IO) {
            history += OllamaChatMessage(Role.USER, content)
            val request = OllamaChatRequest(
                model = LlmModels.MISTRAL.modelName,
                messages = history,
                options = OllamaOptions(
                    temperature = 0.1,
                    topP = 0.95,
                    numCtx = 4096,
                    //stop = listOf("```") // страховка от кодовых блоков
                ),
                stream = false,
                keepAlive = "5m"
            )

            val response = api.chatOnce(request)
            val formatedResponse = response.message.content.replace("`", "")
            history += response.message

            val exec = SshDockerExecutor(username = dataProvider.getUserName(), privateKeyPath = dataProvider.getKeyAbsolutePath())
            val res = exec.runKotlin(formatedResponse)
            res
        }
    }

    suspend fun callLlmToDockerTest(content: String): RunResult {
        return withContext(Dispatchers.IO) {
            history += OllamaChatMessage(Role.USER, content)
            val request = OllamaChatRequest(
                model = LlmModels.MISTRAL.modelName,
                messages = history,
                options = OllamaOptions(
                    temperature = 0.1,
                    topP = 0.95,
                    numCtx = 4096,
                    //stop = listOf("```") // страховка от кодовых блоков
                ),
                stream = false,
                keepAlive = "5m"
            )

            val response = api.chatOnce(request)
            val testsFromLlm = sanitizeTestsCode(response.message.content).trim()
            history += response.message

            // 3) Склеиваем в один компилируемый файл
            val testShim = """
// --- TEST SHIM (no external libs) ---
private fun __assertEquals(name: String, expected: Any?, actual: Any?) {
    if (expected == actual) {
        println("✅ PASS: ${'$'}name")
    } else {
        println("❌ FAIL: ${'$'}name (expected=${'$'}expected, actual=${'$'}actual)")
        throw RuntimeException("Assertion failed: ${'$'}name")
    }
}
private fun __assertTrue(name: String, cond: Boolean) = __assertEquals(name, true, cond)
private fun __assertFalse(name: String, cond: Boolean) = __assertEquals(name, false, cond)
inline fun <reified T: Any> Any?.isInstanceOf() = this is T
inline fun withTest(name: String, block: () -> Unit) {
    try { block() } catch (t: Throwable) { println("❌ FAIL group: ${'$'}name: ${'$'}{t.message}"); throw t }
}
// Aliases to match kotlin.test-style names if LLM emits them
private fun assertEquals(expected: Any?, actual: Any?) = __assertEquals("assertEquals", expected, actual)
private fun assertEquals(name: String, expected: Any?, actual: Any?) = __assertEquals(name, expected, actual)
private fun assertTrue(cond: Boolean) = __assertTrue("assertTrue", cond)
private fun assertTrue(name: String, cond: Boolean) = __assertTrue(name, cond)
private fun assertFalse(cond: Boolean) = __assertFalse("assertFalse", cond)
private fun assertFalse(name: String, cond: Boolean) = __assertFalse(name, cond)
""".trimIndent()

            val hasMain = Regex("""(?m)^\s*fun\s+main\s*\(""").containsMatchIn(content)

            val combined = buildString {
                append(content.trim())
                append("\n\n")
                append(testShim)
                append("\n\n// --- AUTOGENERATED TESTS ---\n")
                append(testsFromLlm)
                append("\n")
                if (!hasMain) {
                    append("\n// --- ENTRYPOINT ---\n")
                    append("fun main() { __runTests() }\n")
                }
            }

            val exec = SshDockerExecutor(username = dataProvider.getUserName(), privateKeyPath = dataProvider.getKeyAbsolutePath())
            val res = exec.runKotlin(combined)
            res
        }
    }

    // --- Helpers ---
    private fun extractFirstCodeBlock(text: String): String {
        val fenceKotlin = Regex("```(?:kotlin|kt)\\s*\\n([\\s\\S]*?)```", RegexOption.IGNORE_CASE)
        val anyFence = Regex("```\\s*\\n([\\s\\S]*?)```")
        return fenceKotlin.find(text)?.groupValues?.get(1)
            ?: anyFence.find(text)?.groupValues?.get(1)
            ?: text
    }

    private fun sanitizeTestsCode(raw: String): String {
        val extracted = extractFirstCodeBlock(raw)
        return extracted
            .lineSequence()
            .filterNot { line ->
                val t = line.trim()
                t.equals("kotlin", ignoreCase = true) || t.startsWith("import kotlin.test")
            }
            .joinToString("\n")
            .trim()
    }
}
